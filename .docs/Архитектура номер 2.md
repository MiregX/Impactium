Имаджинируем дефиниции:
Приложение 1: "Белое" приложение которое прошло модерацию, и к которому со стороны страйпа претензий нет.
Приложение 2: "Серое" приложение, для которого и необходимо скрыть оплату.

Если посидеть и подумать то первая задача не выглядит настолько сложной, как можно подумать. Можно перенять некий опыт с моего прошлого места работы, тематику которой, страйп тоже не очень то и любил, тоесть дейтинг.

Первые месяцы тоже были проблемы с модерацией. Общими силами команды мы пришли к неочевидному решению - продавать пакет услуг, включающий AI решения. 
##### Решение первое (для подписок):
Предположим что в модалке ведущей к оплате, внутри приложения, упоминается премиум подписка, включающая в себе, предположим, улучшенную услугу общения с чат-ботом (например увеличенный лимит до N сообщений в сутки), или любую другую услугу премиум-сегмента.
В список таковых может входить:
1. FullHD / 4K стиминг и качество
2. Больше битрейт (т.е. пропускная способность)
3. Особый значок спонсора(?) в онлайн-чате с моделью или коментариях
		В зависимости от направления приложения, так как можно сделать по мотивам OnlyFans, а можно как на PornHub)
4. Придумать можно что угодно.

Можно как обьеденить несколько подходов, так и перебором, тестируя гипотезы, сравнивая на промежутке времени кол-во мозгоёбки со страйпом, разделённое на кол-во лидов.

##### Решение второе (для счёта):
Если же мы говорим об оплате по факту, чтобы допустим модель засунула себе арбуз в очко за 20 дихмар, то можно вводить условные "фишки", которые будут работать как в первом, так и во втором приложении. С точки зрения архитектуры, первое и второе приложение могут быть объединены общими таблицами "пользователи", "подписки" или "баланс".

Например как это сделано в TT, где пополнение счёта не происходит, а начисляются "фишки", которыми можно расплачиватся внутри одной сети приложений. В нашем случае, инициализация происходит во втором приложении, покупается через первое приложение, начисления на оба (в один аккаунт). Со стороны страйпа они только увидят что клиент купил 10 картинок персиков за 50$ (аналогия очень абстрактная, тут, как и со всем другим нужно привлекать методы тестирования визуала и ценообразования, для увеличения конверсии).

Приложения имеют общий корень в названии, или матч по всем словам в названии, кроме последнего слова, где приложение 2 будет иметь "приписку". С точки зрения конверсии, теряем мы немного, около 2%, из-за различий в названии, но на практике нужно будет при помощи аналитических инструментов (того-же customer.io) узнать актуальный процент, и провести A/B тестирование разных названий, как для обеих приложений, так и описаний услуг, отображающихся в модалке оплаты.

Главное в этом деле не проебатся с технической стороны, ведь простой заголовок запроса Referrer: "https://erotic.something.com" попадёт под паттерн репортинга страйпа, что вызовет ручную проверку, а нам такого не нужно.

##### Решение третье (разделение):
Гипотетически можно использовать сторонний платежный процессор для эротических воронок. Например используем Stripe исключительно для белых воронок, а вот для эротических воронок интегрируем сторонний платежный процессор, который разрешает такой контент (например, Verotel, CCBill). Если шишка дымится - клиент будет готов по номеру телефона переводить.
Минусы:
1. Архитектурно, нужно будет разрабатывать маштабируемое решение, если один из платёжных процессоров обьебнёт, чтобы быстро внедритть новый
2. Изначально в ТЗ не входило, а значит, скорее всего, такой очевидный вариант рассматривался, но был отвергнут в силу непонятных на данный момент мне причин.
Особенности:
1. Разрабатываем воронки так, чтобы они выглядели одинаково, но программно направляем потоки платежей на разные процессоры в зависимости от контента.
2. Использование segment.io или customer.io для объединения аналитики платежей на нескольких процессорах.

##### Решение четыре (абсурдное):
Для IP-адресов Stripe и других инструментов мониторинга всегда обслуживать белую воронку.
Минусы:
1. Непонятно где (скорее всего что есть, но платно) взять базу адресов, и стабильно обновлять
2. Доп. сервис/либа в стек, для маскировки, например fraudfilter.io (или cloudflare, но сказать точно сложно, нужен ресёрч, в случае выбора этого варианта как теоретически возможного)
   


### Задача 2:
Мой выбор пал на микропенисную архитектуру (стандарт в наше время так-то).
 1. Микросервис на GoLang
 2. Ендпоинт, например of.com/api/v2/vote/:rate (внимание на v2)
 3. Отдельная база-данных (GraphQL), для хранения значений, кто, сколько, чтобы исключить возможность двойного воута
 4. Redis общий с **Master** сервером для выдачи оценок, в user.data.info +- c TTL в 30 минут.

При входе пользователя в приложение (по желанию):
Front:
	WebSocket:
	    Golang:
		    Subscribe to GraphQL.userId
Для того, чтобы при добавлении оценки обновлять в реальном времени. Или сократить путь, но пострадает кеш в master сервере.

При добавлении/редактировании цепочки:
Front:
	Nginx (/api/v2):
		GoLang (валидация):
			RabbitMQ (очередь):
				GraphQL
Если при редактировании, предыдущее сообщение всё ещё в очереди:
	Взять сообщение, старое удалить
		Обьеденить новую оценку со старой (Object.assign(old, new))
			Перезаписать в очередь

На стороне клиента сразу отобразить что оценка изменена, для улучшения перформанса (ну типа прикольно оценка сразу поменялась). В любом месте можно спокойно заменить GO на Nest, разница (тянуть ползунок) между скоростью разработки и производительностью.

Можно на самом деле поиграть с комбинациями, протестировать аглоритмом дейкстры (шучу ((`а может и нет`))). Тут каждое решение в той или инной мере хорошее, вряд-ли смогу назвать наилучшее решение, без полного виденья проекта, которого ни у кого нет. Остаётся только протестировать. Думаю если созвонимся, могу обьяснить некоторые моменты, и сказать, где можно сократить, в зависимости от тонкостей. Можно например напрямую фронт с базой обьеденить, разрешив только гет запросы с конкретными полями, можно и Prisma с CockroachDB, но это если нужно без гемора, и быстро маштабировать систему на несколько континентов.